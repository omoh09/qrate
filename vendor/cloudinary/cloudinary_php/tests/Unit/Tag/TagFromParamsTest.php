<?php
/**
 * This file is part of the Cloudinary PHP package.
 *
 * (c) Cloudinary
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Cloudinary\Test\Unit\Tag;

use Cloudinary\ArrayUtils;
use Cloudinary\Asset\Media;
use Cloudinary\Cache\Adapter\KeyValueCacheAdapter;
use Cloudinary\Cache\ResponsiveBreakpointsCache;
use Cloudinary\Configuration\Configuration;
use Cloudinary\Tag\ImageTag;
use Cloudinary\Tag\Tag;
use Cloudinary\Tag\VideoTag;
use Cloudinary\Test\Unit\Cache\Storage\DummyCacheStorage;
use DOMDocument;

/**
 * Class TagFromParamsTest
 */
final class TagFromParamsTest extends ImageTagTestCase
{
    const API_KEY    = 'a';
    const API_SECRET = 'b';

    const DEFAULT_PATH        = 'http://res.cloudinary.com/test123';
    const DEFAULT_UPLOAD_PATH = 'http://res.cloudinary.com/test123/image/upload/';
    const VIDEO_UPLOAD_PATH   = 'http://res.cloudinary.com/test123/video/upload/';

    private static $public_id                 = 'sample.jpg';
    private static $common_transformation_str = 'e_sepia';
    private static $min_width                 = 100;
    private static $max_width                 = 399;
    private static $max_images;
    private static $custom_attributes         = ['custom_attr1' => 'custom_value1', 'custom_attr2' => 'custom_value2'];
    private static $common_image_options      = [
        'effect'       => 'sepia',
        'cloud_name'   => 'test123',
        'client_hints' => false,
    ];
    private static $fill_transformation;
    private static $fill_trans_str;
    private static $common_srcset;
    private static $breakpoints_arr;
    private static $sizes_attr;

    public static function setUpBeforeClass()
    {
        self::$breakpoints_arr = [self::$min_width, 200, 300, self::$max_width];
        self::$max_images      = count(self::$breakpoints_arr);
        self::$common_srcset   = ['breakpoints' => self::$breakpoints_arr];

        self::$fill_transformation = ['width' => self::$max_width, 'height' => self::$max_width, 'crop' => 'fill'];
        self::$fill_trans_str      = 'c_fill,h_' . self::$max_width . ',w_' . self::$max_width;

        self::$sizes_attr = implode(
            ', ',
            array_map(
                static function ($w) {
                    return "(max-width: ${w}px) ${w}px";
                },
                self::$breakpoints_arr
            )
        );
    }


    public function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        self::markTestSkipped('Finish fromParams');
    }

    public function testImageTag()
    {
        $tag = ImageTag::fromParams('test', ['width' => 10, 'height' => 10, 'crop' => 'fill', 'format' => 'png']);
        $this->assertStrEquals(
            "<img src='" . self::DEFAULT_UPLOAD_PATH . "c_fill,h_10,w_10/test.png' height='10' width='10'/>",
            $tag
        );
    }

    /**
     * Should create a meta tag with client hints
     */
    public function testClientHintsMetaTag()
    {
        $doc = new DOMDocument();
        $doc->loadHTML(Tag::clientHintsMetaTag());
        $tags = $doc->getElementsByTagName('meta');
        $this->assertEquals($tags->length, 1);
        $this->assertEquals($tags->item(0)->getAttribute('content'), 'DPR, Viewport-Width, Width');
        $this->assertEquals($tags->item(0)->getAttribute('http-equiv'), 'Accept-CH');
    }

    /**
     * Check that ImageTag encodes special characters.
     */
    public function testImageTagSpecialCharactersEncoding()
    {
        $tag      = ImageTag::fromParams(
            "test's special < \"characters\" >",
            ['width' => 10, 'height' => 10, 'crop' => 'fill', 'format' => 'png', 'alt' => "< test's > special \""]
        );
        $expected = "<img src='" . self::DEFAULT_UPLOAD_PATH . 'c_fill,h_10,w_10/' .
                    "test%27s%20special%20%3C%20%22characters%22%20%3E.png'" .
                    " alt='&lt; test&#039;s &gt; special &quot;' height='10' width='10'/>";

        $this->assertStrEquals($expected, $tag);
    }

    public function testResponsiveWidth()
    {
        // should add responsive width transformation
        $tag = ImageTag::fromParams('hello', ['responsive_width' => true, 'format' => 'png']);
        $this->assertStrEquals(
            "<img class='cld-responsive' data-src='" . self::DEFAULT_UPLOAD_PATH . "c_limit,w_auto/hello.png'/>",
            $tag
        );

        $options = ['width' => 100, 'height' => 100, 'crop' => 'crop', 'responsive_width' => true];
        $result  = Media::fromParams('test', $options);
        $this->assertEquals($options, ['responsive' => true]);
        $this->assertEquals($result, self::DEFAULT_UPLOAD_PATH . 'c_crop,h_100,w_100/c_limit,w_auto/test');
        Configuration::instance()->importJson(
            [
                'responsive_width_transformation' => [
                    'width' => 'auto:breakpoints',
                    'crop'  => 'pad',
                ],
            ]
        );
        $options = ['width' => 100, 'height' => 100, 'crop' => 'crop', 'responsive_width' => true];
        $result  = Media::fromParams('test', $options);
        $this->assertEquals($options, ['responsive' => true]);
        $this->assertStrEquals(
            $result,
            self::DEFAULT_UPLOAD_PATH . 'c_crop,h_100,w_100/c_pad,w_auto:breakpoints/test'
        );
    }

    public function testWidthAuto()
    {
        // should support width=auto
        $tag = ImageTag::fromParams('hello', ['width' => 'auto', 'crop' => 'limit', 'format' => 'png']);
        $this->assertStrEquals(
            "<img class='cld-responsive' data-src='" . self::DEFAULT_UPLOAD_PATH . "c_limit,w_auto/hello.png'/>",
            $tag
        );
        $tag = ImageTag::fromParams('hello', ['width' => 'auto:breakpoints', 'crop' => 'limit', 'format' => 'png']);
        $this->assertStrEquals(
            "<img class='cld-responsive' data-src='" .
            self::DEFAULT_UPLOAD_PATH . "c_limit,w_auto:breakpoints/hello.png'/>",
            $tag
        );
        $this->assertCloudinaryUrl(
            'test',
            ['width' => 'auto:20', 'crop' => 'fill'],
            self::DEFAULT_UPLOAD_PATH . 'c_fill,w_auto:20/test',
            ['responsive' => true]
        );
        $this->assertCloudinaryUrl(
            'test',
            ['width' => 'auto:20:350', 'crop' => 'fill'],
            self::DEFAULT_UPLOAD_PATH . 'c_fill,w_auto:20:350/test',
            ['responsive' => true]
        );
        $this->assertCloudinaryUrl(
            'test',
            ['width' => 'auto:breakpoints', 'crop' => 'fill'],
            self::DEFAULT_UPLOAD_PATH . 'c_fill,w_auto:breakpoints/test',
            ['responsive' => true]
        );
        $this->assertCloudinaryUrl(
            'test',
            ['width' => 'auto:breakpoints_100_1900_20_15', 'crop' => 'fill'],
            self::DEFAULT_UPLOAD_PATH . 'c_fill,w_auto:breakpoints_100_1900_20_15/test',
            ['responsive' => true]
        );
        $this->assertCloudinaryUrl(
            'test',
            ['width' => 'auto:breakpoints:json', 'crop' => 'fill'],
            self::DEFAULT_UPLOAD_PATH . 'c_fill,w_auto:breakpoints:json/test',
            ['responsive' => true]
        );
    }

    /**
     * @param        $options
     * @param string $message
     */
    public function sharedClientHints($options, $message = '')
    {
        $tag = ImageTag::fromParams('sample.jpg', $options);
        $this->assertStrEquals(
            "<img src='http://res.cloudinary.com/test/image/upload/c_scale,dpr_auto,w_auto/sample.jpg' />",
            $tag,
            $message
        );
        $tag = ImageTag::fromParams('sample.jpg', array_merge(['responsive' => true], $options));
        $this->assertStrEquals(
            "<img src='http://res.cloudinary.com/test/image/upload/c_scale,dpr_auto,w_auto/sample.jpg' />",
            $tag,
            $message
        );
    }

    public function testClientHintsAsOption()
    {
        $this->sharedClientHints(
            [
                'dpr'          => 'auto',
                'cloud_name'   => 'test',
                'width'        => 'auto',
                'crop'         => 'scale',
                'client_hints' => true,
            ],
            'support client_hints as an option'
        );
    }

    public function testClientHintsAsGlobal()
    {
        Configuration::instance()->importJson(['client_hints' => true]);
        $this->sharedClientHints(
            [
                'dpr'        => 'auto',
                'cloud_name' => 'test',
                'width'      => 'auto',
                'crop'       => 'scale',
            ],
            'support client hints as global configuration'
        );
    }

    public function testClientHintsFalse()
    {
        Configuration::instance()->importJson(['responsive' => true]);
        $tag = ImageTag::fromParams(
            'sample.jpg',
            [
                'width'        => 'auto',
                'crop'         => 'scale',
                'cloud_name'   => 'test123',
                'client_hints' => false,
            ]
        );
        $this->assertStrEquals(
            "<img class='cld-responsive' data-src='" . self::DEFAULT_UPLOAD_PATH . "c_scale,w_auto/sample.jpg'/>",
            $tag,
            'should use normal responsive behaviour'
        );
    }

    /**
     * Should create srcset attribute with provided breakpoints
     */
    public function test_image_tag_srcset()
    {
        $expected_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            self::$breakpoints_arr
        );

        $tag_with_breakpoints = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                ['srcset' => self::$common_srcset]
            )
        );

        $this->assertEquals(
            $expected_tag,
            $tag_with_breakpoints,
            'Should create img srcset attribute with provided breakpoints'
        );
    }

    public function testSupportSrcsetAttributeDefinedByMinWidthMaxWidthAndMaxImages()
    {
        $tag_min_max_count = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                [
                    'srcset' => [
                        'min_width'  => self::$min_width,
                        'max_width'  => $x = self::$max_width,
                        'max_images' => count(self::$breakpoints_arr),
                    ],
                ]
            )
        );

        $expected_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            self::$breakpoints_arr
        );

        $this->assertStrEquals(
            $expected_tag,
            $tag_min_max_count,
            'Should support srcset attribute defined by min_width, max_width, and max_images'
        );

        // Should support 1 image in srcset
        $tag_one_image_by_params = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                [
                    'srcset' => [
                        'min_width'  => self::$breakpoints_arr[0],
                        'max_width'  => self::$max_width,
                        'max_images' => 1,
                    ],
                ]
            )
        );

        $expected_1_image_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            [self::$max_width]
        );

        $this->assertStrEquals($expected_1_image_tag, $tag_one_image_by_params);

        $tag_one_image_by_breakpoints = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                ['srcset' => ['breakpoints' => [self::$max_width]]]
            )
        );
        $this->assertStrEquals($expected_1_image_tag, $tag_one_image_by_breakpoints);

        // Should support custom transformation for srcset items
        $custom_transformation = ['transformation' => ['crop' => 'crop', 'width' => 10, 'height' => 20]];

        $tag_custom_transformation = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                [
                    'srcset' => array_merge(
                        self::$common_srcset,
                        $custom_transformation
                    ),
                ]
            )
        );

        $custom_transformation_str = 'c_crop,h_20,w_10';
        $custom_expected_tag       = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            $custom_transformation_str,
            self::$breakpoints_arr
        );

        $this->assertStrEquals($custom_expected_tag, $tag_custom_transformation);

        // Should populate sizes attribute
        $tag_with_sizes = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                [
                    'srcset' => array_merge(
                        self::$common_srcset,
                        ['sizes' => true]
                    ),
                ]
            )
        );

        $expected_tag_with_sizes = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            self::$breakpoints_arr,
            ['sizes' => self::$sizes_attr]
        );
        $this->assertStrEquals($expected_tag_with_sizes, $tag_with_sizes);

        // Should support srcset string value
        $raw_srcset_value    = 'some srcset data as is';
        $tag_with_raw_srcset = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                ['attributes' => ['srcset' => $raw_srcset_value]]
            )
        );

        $expected_raw_srcset = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            [],
            ['srcset' => $raw_srcset_value]
        );

        $this->assertStrEquals($expected_raw_srcset, $tag_with_raw_srcset);

        // Should remove width and height attributes in case srcset is specified, but passed to transformation
        $tag_with_sizes = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                array_merge(
                    self::$common_image_options,
                    ['width' => 500, 'height' => 500]
                ),
                ['srcset' => self::$common_srcset]
            )
        );

        $expected_tag_without_width_and_height = self::expectedImageTagFromParams(
            self::$public_id,
            'e_sepia,h_500,w_500',
            '',
            self::$breakpoints_arr
        );
        $this->assertStrEquals($expected_tag_without_width_and_height, $tag_with_sizes);
    }

    /**
     * Should omit srcset attribute on invalid values
     *
     * @throws \Exception
     */
    public function testSrcsetInvalidValues()
    {
        $invalid_breakpoints = [
            ['sizes' => true],                                             // srcset data not provided
            ['max_width' => 300, 'max_images' => 3],                       // no min_width
            ['min_width' => '1', 'max_width' => 300, 'max_images' => 3],   // invalid min_width
            ['min_width' => 100, 'max_images' => 3],                       // no max_width
            ['min_width' => '1', 'max_width' => '3', 'max_images' => 3],   // invalid max_width
            ['min_width' => 200, 'max_width' => 100, 'max_images' => 3],   // min_width > max_width
            ['min_width' => 100, 'max_width' => 300],                      // no max_images
            ['min_width' => 100, 'max_width' => 300, 'max_images' => 0],   // invalid max_images
            ['min_width' => 100, 'max_width' => 300, 'max_images' => -17], // invalid max_images
            ['min_width' => 100, 'max_width' => 300, 'max_images' => '3'], // invalid max_images
            ['min_width' => 100, 'max_width' => 300, 'max_images' => null], // invalid max_images
        ];


        $err_log_original_destination = ini_get('error_log');
        // Suppress error messages in error log
        ini_set('error_log', '/dev/null');

        try {
            foreach ($invalid_breakpoints as $value) {
                $tag = ImageTag::fromParams(
                    self::$public_id,
                    array_merge(self::$common_image_options, ['srcset' => $value])
                );

                self::assertNotContains('srcset', $tag);
            }
        } catch (\Exception $e) {
            ini_set('error_log', $err_log_original_destination);
            throw $e;
        }

        ini_set('error_log', $err_log_original_destination);
    }

    public function testImageTagResponsiveBreakpointsCache()
    {
        $cache = ResponsiveBreakpointsCache::instance();
        $cache->setCacheAdapter(new KeyValueCacheAdapter(new DummyCacheStorage()));

        $asset  = Media::fromParams(self::$public_id, self::$common_image_options);
        $cache->set($asset, self::$breakpoints_arr);

        $expected_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            self::$breakpoints_arr
        );

        $image_tag = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                ['srcset' => ['use_cache' => true]]
            )
        );

        $this->assertEquals($expected_tag, $image_tag);
    }

    public function testCreateATagWithCustomAttributesLegacyApproach()
    {
        $tag_with_custom_legacy_attribute = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                self::$custom_attributes
            )
        );

        $expected_custom_attributes_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            [],
            self::$custom_attributes
        );

        $this->assertStrEquals($expected_custom_attributes_tag, $tag_with_custom_legacy_attribute);
    }

    public function testCreateATagWithLegacySrcsetAttribute()
    {
        $srcset_attribute                 = ['srcset' => 'http://custom.srcset.attr/sample.jpg 100w'];
        $tag_with_custom_srcset_attribute = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                $srcset_attribute
            )
        );

        $expected_custom_attributes_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            [],
            $srcset_attribute
        );

        $this->assertStrEquals($expected_custom_attributes_tag, $tag_with_custom_srcset_attribute);
    }


    public function testConsumeCustomAttributesFromAttributesKey()
    {
        $tag_with_custom_attribute      = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                ['attributes' => self::$custom_attributes]
            )
        );
        $expected_custom_attributes_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            [],
            self::$custom_attributes
        );
        $this->assertStrEquals($expected_custom_attributes_tag, $tag_with_custom_attribute);
    }

    public function testOverrideExistingAttributesWithSpecifiedByCustomOnes()
    {
        $updated_attributes                  = ['alt' => 'updated alt'];
        $tag_with_custom_overriden_attribute = ImageTag::fromParams(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                ['alt' => 'original alt', 'attributes' => $updated_attributes]
            )
        );

        $expected_overriden_attributes_tag = self::expectedImageTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            [],
            $updated_attributes
        );
        $this->assertEquals($expected_overriden_attributes_tag, $tag_with_custom_overriden_attribute);
    }

    public function test_dpr_auto()
    {
        // should support width=auto
        $tag = ImageTag::fromParams('hello', ['dpr' => 'auto', 'format' => 'png']);
        $this->assertStrEquals(
            "<img class='cld-hidpi' data-src='" . self::DEFAULT_UPLOAD_PATH . "dpr_auto/hello.png'/>",
            $tag
        );
    }

    public function test_sprite_tag()
    {
        $url = cl_sprite_tag('mytag', ['crop' => 'fill', 'width' => 10, 'height' => 10]);
        $this->assertEquals(
            "<link rel='stylesheet' type='text/css' " .
            "href='" . self::DEFAULT_PATH . "/image/sprite/c_fill,h_10,w_10/mytag.css'>",
            $url
        );
    }

    public function test_video_thumbnail_path()
    {
        $this->assertEquals(cl_video_thumbnail_path('movie_id'), self::VIDEO_UPLOAD_PATH . 'movie_id.jpg');
        $this->assertEquals(
            cl_video_thumbnail_path('movie_id', ['width' => 100]),
            self::VIDEO_UPLOAD_PATH . 'w_100/movie_id.jpg'
        );
    }

    public function test_video_thumbnail_tag()
    {
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie_id.jpg';
        $this->assertEquals(
            cl_video_thumbnail_tag('movie_id'),
            "<img src='$expected_url' />"
        );

        $expected_url = self::VIDEO_UPLOAD_PATH . 'w_100/movie_id.jpg';
        $this->assertEquals(
            cl_video_thumbnail_tag('movie_id', ['width' => 100]),
            "<img src='$expected_url' width='100'/>"
        );
    }

    public function testVideoTag()
    {
        //default
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie';
        $this->assertStrEquals(
            VideoTag::fromParams('movie'),
            "<video poster='$expected_url.jpg'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            '</video>'
        );
    }

    public function testVideoTagWithAttributes()
    {
        //test video attributes
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie';
        $this->assertEquals(
            VideoTag::fromParams(
                'movie',
                ['autoplay' => true, 'controls', 'loop', 'muted' => 'true', 'preload', 'style' => 'border: 1px']
            ),
            "<video autoplay='1' controls loop muted='true' poster='$expected_url.jpg' preload style='border: 1px'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            '</video>'
        );
    }

    public function testVideoTagWithTransformation()
    {
        //test video attributes
        $options      = [
            'source_types' => 'mp4',
            'html_height'  => '100',
            'html_width'   => '200',
            'video_codec'  => ['codec' => 'h264'],
            'audio_codec'  => 'acc',
            'start_offset' => 3,
        ];
        $expected_url = self::VIDEO_UPLOAD_PATH . 'ac_acc,so_3,vc_h264/movie';
        $this->assertEquals(
            VideoTag::fromParams('movie', $options),
            "<video height='100' poster='$expected_url.jpg' src='$expected_url.mp4' width='200'></video>"
        );

        unset($options['source_types']);
        $this->assertEquals(
            VideoTag::fromParams('movie', $options),
            "<video height='100' poster='$expected_url.jpg' width='200'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            '</video>'
        );

        unset($options['html_height'], $options['html_width']);
        $options['width'] = 250;
        $expected_url     = self::VIDEO_UPLOAD_PATH . 'ac_acc,so_3,vc_h264,w_250/movie';
        $this->assertEquals(
            VideoTag::fromParams('movie', $options),
            "<video poster='$expected_url.jpg' width='250'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            '</video>'
        );

        $expected_url    = self::VIDEO_UPLOAD_PATH . 'ac_acc,c_fit,so_3,vc_h264,w_250/movie';
        $options['crop'] = 'fit';
        $this->assertEquals(
            VideoTag::fromParams('movie', $options),
            "<video poster='$expected_url.jpg'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            '</video>'
        );
    }

    public function testVideoTagWithFallback()
    {
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie';
        $fallback     = "<span id='spanid'>Cannot display video</span>";
        $this->assertEquals(
            VideoTag::fromParams('movie', ['fallback_content' => $fallback]),
            "<video poster='$expected_url.jpg'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            $fallback .
            '</video>'
        );
        $this->assertEquals(
            VideoTag::fromParams('movie', ['fallback_content' => $fallback, 'source_types' => 'mp4']),
            "<video poster='$expected_url.jpg' src='$expected_url.mp4'>" . $fallback . '</video>'
        );
    }

    public function testVideoTagWithSourceTypes()
    {
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie';
        $this->assertEquals(
            VideoTag::fromParams('movie', ['source_types' => ['ogv', 'mp4']]),
            "<video poster='$expected_url.jpg'>" .
            "<source src='$expected_url.ogv' type='video/ogg'>" .
            "<source src='$expected_url.mp4' type='video/mp4'>" .
            '</video>'
        );
    }

    public function testVideoTagWithSourceTransformation()
    {
        $expected_url     = self::VIDEO_UPLOAD_PATH . 'q_50/w_100/movie';
        $expected_ogv_url = self::VIDEO_UPLOAD_PATH . 'q_50/q_70,w_100/movie';
        $expected_mp4_url = self::VIDEO_UPLOAD_PATH . 'q_50/q_30,w_100/movie';
        $this->assertEquals(
            VideoTag::fromParams(
                'movie',
                [
                    'width'                 => 100,
                    'transformation'        => [['quality' => 50]],
                    'source_transformation' => [
                        'ogv' => ['quality' => 70],
                        'mp4' => ['quality' => 30],
                    ],
                ]
            ),
            "<video poster='$expected_url.jpg' width='100'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_mp4_url.mp4' type='video/mp4'>" .
            "<source src='$expected_ogv_url.ogv' type='video/ogg'>" .
            '</video>'
        );

        $this->assertEquals(
            VideoTag::fromParams(
                'movie',
                [
                    'width'                 => 100,
                    'transformation'        => [['quality' => 50]],
                    'source_transformation' => [
                        'ogv' => ['quality' => 70],
                        'mp4' => ['quality' => 30],
                    ],
                    'source_types'          => ['webm', 'mp4'],
                ]
            ),
            "<video poster='$expected_url.jpg' width='100'>" .
            "<source src='$expected_url.webm' type='video/webm'>" .
            "<source src='$expected_mp4_url.mp4' type='video/mp4'>" .
            '</video>'
        );
    }

    public function testVideoTagWithPoster()
    {
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie';

        $expected_poster_url = 'http://image/somewhere.jpg';
        $this->assertStrEquals(
            VideoTag::fromParams('movie', ['poster' => $expected_poster_url, 'source_types' => 'mp4']),
            "<video poster='$expected_poster_url' src='$expected_url.mp4'></video>"
        );

        $expected_poster_url = self::VIDEO_UPLOAD_PATH . 'g_north/movie.jpg';
        $this->assertStrEquals(
            VideoTag::fromParams(
                'movie',
                ['poster' => ['gravity' => 'north'], 'source_types' => 'mp4']
            ),
            "<video poster='$expected_poster_url' src='$expected_url.mp4'></video>"
        );

        $expected_poster_url = self::DEFAULT_UPLOAD_PATH . 'g_north/my_poster.jpg';
        $this->assertStrEquals(
            VideoTag::fromParams(
                'movie',
                [
                    'poster'       => ['gravity' => 'north', 'public_id' => 'my_poster', 'format' => 'jpg'],
                    'source_types' => 'mp4',
                ]
            ),
            "<video poster='$expected_poster_url' src='$expected_url.mp4'></video>"
        );

        $this->assertStrEquals(
            VideoTag::fromParams('movie', ['poster' => null, 'source_types' => 'mp4']),
            "<video src='$expected_url.mp4'></video>"
        );

        $this->assertStrEquals(
            VideoTag::fromParams('movie', ['poster' => false, 'source_types' => 'mp4']),
            "<video src='$expected_url.mp4'></video>"
        );
    }

    /**
     * Check that VideoTag::fromParams encodes special characters.
     */
    public function testVideoTagSpecialCharactersEncoding()
    {
        $expected_url = self::VIDEO_UPLOAD_PATH . 'movie%27s%20id%21%40%23%24%25%5E%26%2A%28';

        $this->assertEquals(
            "<video poster='$expected_url.jpg' src='$expected_url.mp4'></video>",
            VideoTag::fromParams("movie's id!@#$%^&*(", ['source_types' => 'mp4'])
        );
    }

    public function testVideoTagDefaultSources()
    {
        $expected_url = self::VIDEO_UPLOAD_PATH . '%smovie.%s';

        $this->assertStrEquals(
            "<video poster='" . sprintf($expected_url, '', 'jpg') . "'>" .
            "<source src='" . sprintf($expected_url, 'vc_h265/', 'mp4') . "' type='video/mp4; codecs=hev1'>" .
            "<source src='" . sprintf($expected_url, 'vc_vp9/', 'webm') . "' type='video/webm; codecs=vp9'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'mp4') . "' type='video/mp4'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'webm') . "' type='video/webm'>" .
            '</video>',
            VideoTag::fromParams('movie', ['sources' => VideoTag::defaultVideoSources()])
        );
    }

    public function testVideoTagCustomSources()
    {
        $custom_sources = [
            [
                'type'            => 'mp4',
                'codecs'          => 'vp8, vorbis',
                'transformations' => ['video_codec' => 'auto'],
            ],
            [
                'type'            => 'webm',
                'codecs'          => 'avc1.4D401E, mp4a.40.2',
                'transformations' => ['video_codec' => 'auto'],
            ],
        ];

        $expected_url   = self::VIDEO_UPLOAD_PATH . '%smovie.%s';

        $this->assertStrEquals(
            "<video poster='" . sprintf($expected_url, '', 'jpg') . "'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'mp4') .
            "' type='video/mp4; codecs=vp8, vorbis'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'webm') .
            "' type='video/webm; codecs=avc1.4D401E, mp4a.40.2'>" .
            '</video>',
            VideoTag::fromParams('movie', ['sources' => $custom_sources])
        );
    }

    public function testVideoTagSourcesCodecsArray()
    {
        $custom_sources = [
            [
                'type'            => 'mp4',
                'codecs'          => ['vp8', 'vorbis'],
                'transformations' => ['video_codec' => 'auto'],
            ],
            [
                'type'            => 'webm',
                'codecs'          => ['avc1.4D401E', 'mp4a.40.2'],
                'transformations' => ['video_codec' => 'auto'],
            ],
        ];
        $expected_url   = self::VIDEO_UPLOAD_PATH . '%smovie.%s';

        $this->assertStrEquals(
            "<video poster='" . sprintf($expected_url, '', 'jpg') . "'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'mp4') .
            "' type='video/mp4; codecs=vp8, vorbis'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'webm') .
            "' type='video/webm; codecs=avc1.4D401E, mp4a.40.2'>" .
            '</video>',
            VideoTag::fromParams('movie', ['sources' => $custom_sources])
        );
    }

    public function test_video_tag_sources_with_transformation()
    {
        $options      = [
            'source_types' => 'mp4',
            'html_height'  => '100',
            'html_width'   => '200',
            'video_codec'  => ['codec' => 'h264'],
            'audio_codec'  => 'acc',
            'start_offset' => 3,
            'sources'      => VideoTag::defaultVideoSources(),
        ];
        $expected_url = self::VIDEO_UPLOAD_PATH . 'ac_acc,so_3,%smovie.%s';

        $this->assertStrEquals(
            "<video height='100' poster='" . sprintf($expected_url, 'vc_h264/', 'jpg') . "' width='200'>" .
            "<source src='" . sprintf($expected_url, 'vc_h265/', 'mp4') . "' type='video/mp4; codecs=hev1'>" .
            "<source src='" . sprintf($expected_url, 'vc_vp9/', 'webm') . "' type='video/webm; codecs=vp9'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'mp4') . "' type='video/mp4'>" .
            "<source src='" . sprintf($expected_url, 'vc_auto/', 'webm') . "' type='video/webm'>" .
            '</video>',
            VideoTag::fromParams('movie', $options)
        );
    }

    public function test_upload_tag()
    {
        $pattern = "/<input class='cloudinary-fileupload' " .
                   "data-cloudinary-field='image' " .
                   "data-form-data='{\&quot;timestamp\&quot;:\d+,\&quot;signature\&quot;:\&quot;\w+\&quot;," .
                   "\&quot;api_key\&quot;:\&quot;a\&quot;}' " .
                   "data-url='http[^']+\/v1_1\/test123\/auto\/upload' " .
                   "name='file' type='file'\/>/";
        $this->assertRegExp($pattern, cl_upload_tag('image'));
        $this->assertRegExp($pattern, cl_image_upload_tag('image'));

        $pattern = "/<input class='cloudinary-fileupload' " .
                   "data-cloudinary-field='image' " .
                   "data-form-data='{\&quot;timestamp\&quot;:\d+,\&quot;signature\&quot;:\&quot;\w+\&quot;," .
                   "\&quot;api_key\&quot;:\&quot;a\&quot;}' " .
                   "data-max-chunk-size='5000000' " .
                   "data-url='http[^']+\/v1_1\/test123\/auto\/upload_chunked' " .
                   "name='file' type='file'\/>/";
        $this->assertRegExp(
            $pattern,
            cl_upload_tag('image', ['chunk_size' => 5000000])
        );

        $pattern = "/<input class='classy cloudinary-fileupload' " .
                   "data-cloudinary-field='image' " .
                   "data-form-data='{\&quot;timestamp\&quot;:\d+,\&quot;signature\&quot;:\&quot;\w+\&quot;," .
                   "\&quot;api_key\&quot;:\&quot;a\&quot;}' " .
                   "data-url='http[^']+\/v1_1\/test123\/auto\/upload' " .
                   "name='file' type='file'\/>/";
        $this->assertRegExp(
            $pattern,
            cl_upload_tag('image', ['html' => ['class' => 'classy']])
        );
    }

    public function test_source_tag()
    {
        $expected_tag = $this->expectedSourceTagFromParams(
            self::$public_id,
            self::$common_transformation_str,
            '',
            self::$breakpoints_arr,
            ['sizes' => self::$sizes_attr, 'media' => generate_media_attr(['max_width' => self::$max_width])]
        );

        $source_tag_with_srcset = cl_source_tag(
            self::$public_id,
            array_merge(
                self::$common_image_options,
                [
                    'srcset' => array_merge(
                        self::$common_srcset,
                        ['sizes' => true]
                    ),
                ],
                [
                    'media' => ['max_width' => self::$max_width],
                ]
            )
        );

        $this->assertEquals(
            $expected_tag,
            $source_tag_with_srcset,
            'Should create source tag with srcset and sizes attributes with provided breakpoints'
        );
    }

    public function test_picture_tag()
    {
        $tag = cl_picture_tag(
            self::$public_id,
            self::$fill_transformation,
            [
                [
                    'max_width'      => self::$min_width,
                    'transformation' => ['effect' => 'sepia', 'angle' => 17, 'width' => self::$min_width],
                ],
                [
                    'min_width'      => self::$min_width,
                    'max_width'      => self::$max_width,
                    'transformation' => ['effect' => 'colorize', 'angle' => 18, 'width' => self::$max_width],

                ],
                [
                    'min_width'      => self::$max_width,
                    'transformation' => ['effect' => 'blur', 'angle' => 19, 'width' => self::$max_width],
                ],
            ]
        );


        $expected_source1 = self::expectedSourceTagFromParams(
            self::$public_id,
            self::$fill_trans_str . '/' . 'a_17,e_sepia,w_' . self::$min_width,
            '',
            [],
            ['media' => generate_media_attr(['max_width' => self::$min_width])]
        );

        $expected_source2 = self::expectedSourceTagFromParams(
            self::$public_id,
            self::$fill_trans_str . '/' . 'a_18,e_colorize,w_' . self::$max_width,
            '',
            [],
            ['media' => generate_media_attr(['min_width' => self::$min_width, 'max_width' => self::$max_width])]

        );

        $expected_source3 = self::expectedSourceTagFromParams(
            self::$public_id,
            self::$fill_trans_str . '/' . 'a_19,e_blur,w_' . self::$max_width,
            '',
            [],
            ['media' => generate_media_attr(['min_width' => self::$max_width])]
        );

        $expected_img = self::expectedImageTagFromParams(
            self::$public_id,
            self::$fill_trans_str,
            '',
            [],
            ['height' => self::$max_width, 'width' => self::$max_width]
        );

        $exp = '<picture>' . $expected_source1 . $expected_source2 . $expected_source3 . $expected_img . '</picture>';

        $this->assertEquals($exp, $tag);
    }

    /**
     * @param       $source
     * @param       $options
     * @param       $expected
     * @param array $expected_options
     */
    private function assertCloudinaryUrl($source, $options, $expected, $expected_options = [])
    {
        $url = Media::fromParams($source, $options);
        $this->assertEquals($expected_options, $options);
        $this->assertEquals($expected, $url);
    }

    /**
     * @param string $tag_name              Expected tag name(img or source)
     * @param string $public_id             Public ID of the image
     * @param string $common_trans_str      Default transformation string to be used in all resources
     * @param string $custom_trans_str      Optional custom transformation string to be be used inside srcset resources
     *                                      If not provided, $common_trans_str is used
     * @param array  $srcset_breakpoints    Optional list of breakpoints for srcset. If not provided srcset is omitted
     * @param array  $attributes            Associative array of custom attributes to be added to the tag
     *
     * @param bool   $is_void               Indicates whether tag is an HTML5 void tag (does not need to be self-closed)
     *
     * @return string Resulting tag
     * @internal
     * Helper method for generating expected `img` and `source` tags
     *
     */
    private static function commonImageTagFromParamsHelper(
        $tag_name,
        $public_id,
        $common_trans_str,
        $custom_trans_str = '',
        $srcset_breakpoints = [],
        $attributes = [],
        $is_void = false
    ) {
        if (empty($custom_trans_str)) {
            $custom_trans_str = $common_trans_str;
        }

        if (! empty($srcset_breakpoints)) {
            $single_srcset_image  = function ($w) use ($custom_trans_str, $public_id) {
                return self::DEFAULT_UPLOAD_PATH . "{$custom_trans_str}/c_scale,w_{$w}/{$public_id} {$w}w";
            };
            $attributes['srcset'] = implode(', ', array_map($single_srcset_image, $srcset_breakpoints));
        }

        $tag = "<$tag_name";

        $attributes_str = implode(
            ' ',
            array_map(
                static function ($k, $v) {
                    return "$k='$v'";
                },
                array_keys($attributes),
                array_values($attributes)
            )
        );

        if (! empty($attributes_str)) {
            $tag .= " {$attributes_str}";
        }

        $tag .= $is_void ? '>' : '/>'; // HTML5 void elements do not need to be self closed

        if (getenv('DEBUG')) {
            echo preg_replace('/([,\']) /', "$1\n    ", $tag) . "\n\n";
        }

        return $tag;
    }

    /**
     * @param string $public_id             Public ID of the image
     * @param string $common_trans_str      Default transformation string to be used in all resources
     * @param string $custom_trans_str      Optional custom transformation string to be be used inside srcset resources
     *                                      If not provided, $common_trans_str is used
     * @param array  $srcset_breakpoints    Optional list of breakpoints for srcset. If not provided srcset is omitted
     * @param array  $attributes            Associative array of custom attributes to be added to the tag
     *
     * @return string Resulting image tag
     * @internal
     * Helper method for test_cl_image_tag_srcset for generating expected image tag
     *
     */
    private static function expectedImageTagFromParams(
        $public_id,
        $common_trans_str,
        $custom_trans_str = '',
        $srcset_breakpoints = [],
        $attributes = []
    ) {
        ArrayUtils::prependAssoc(
            $attributes,
            'src',
            self::DEFAULT_UPLOAD_PATH . "{$common_trans_str}/{$public_id}"
        );

        return self::commonImageTagFromParamsHelper(
            'img',
            $public_id,
            $common_trans_str,
            $custom_trans_str,
            $srcset_breakpoints,
            $attributes
        );
    }

    /**
     * @param string $public_id             Public ID of the image
     * @param string $common_trans_str      Default transformation string to be used in all resources
     * @param string $custom_trans_str      Optional custom transformation string to be be used inside srcset resources
     *                                      If not provided, $common_trans_str is used
     * @param array  $srcset_breakpoints    Optional list of breakpoints for srcset. If not provided srcset is omitted
     * @param array  $attributes            Associative array of custom attributes to be added to the tag
     *
     * @return string Resulting `source` tag
     * @internal
     * Helper method for for generating expected `source` tag
     *
     */
    private static function expectedSourceTagFromParams(
        $public_id,
        $common_trans_str,
        $custom_trans_str = '',
        $srcset_breakpoints = [],
        $attributes = []
    ) {
        $attributes['srcset'] = self::DEFAULT_UPLOAD_PATH . "{$common_trans_str}/{$public_id }";

        ksort($attributes); // Used here to produce output similar to Cloudinary::html_attrs

        return self::commonImageTagFromParamsHelper(
            "source",
            $public_id,
            $common_trans_str,
            $custom_trans_str,
            $srcset_breakpoints,
            $attributes,
            true
        );
    }
}
